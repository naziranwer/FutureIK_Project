{"ast":null,"code":"const useTraverseTree = () => {\n  // Add a file or folder in tree\n  // Can be optimised using Dynamic Programming\n  const insertNode = function (tree, folderId, item, isFolder) {\n    if (tree.id === folderId && tree.isFolder) {\n      tree.items.unshift({\n        id: new Date().getTime(),\n        name: item,\n        isFolder: isFolder,\n        items: []\n      });\n      return tree;\n    }\n    let latestNode = [];\n    latestNode = tree.items.map(ob => {\n      return insertNode(ob, folderId, item, isFolder);\n    });\n    return {\n      ...tree,\n      items: latestNode\n    };\n  };\n  const selectInnerFiles = function (tree, isSelected) {\n    if (tree.isFolder) {\n      tree.isSelected = isSelected;\n      tree.items.forEach(item => {\n        selectInnerFiles(item, isSelected);\n      });\n    } else {\n      tree.isSelected = isSelected;\n    }\n    return tree;\n  };\n  const updateParentSelection = function (tree) {\n    if (tree.isFolder) {\n      let allChildrenSelected = true;\n      for (const item of tree.items) {\n        if (item.isFolder) {\n          updateParentSelection(item); // Recursively update child folders\n        }\n\n        if (!item.isSelected) {\n          allChildrenSelected = false;\n          break;\n        }\n      }\n      tree.isSelected = allChildrenSelected;\n    }\n  };\n  const selectNode = function (tree, folderId) {\n    if (tree.id === folderId) {\n      return selectInnerFiles(tree, !tree.isSelected);\n    }\n    tree.items.forEach(item => {\n      selectNode(item, folderId);\n    });\n    updateParentSelection(tree);\n    return tree;\n  };\n  return {\n    insertNode,\n    selectNode\n  };\n};\nexport default useTraverseTree;","map":{"version":3,"names":["useTraverseTree","insertNode","tree","folderId","item","isFolder","id","items","unshift","Date","getTime","name","latestNode","map","ob","selectInnerFiles","isSelected","forEach","updateParentSelection","allChildrenSelected","selectNode"],"sources":["C:/Users/Admin/futureik/src/hooks/use-traverse-tree.js"],"sourcesContent":["const useTraverseTree = () => {\r\n  // Add a file or folder in tree\r\n  // Can be optimised using Dynamic Programming\r\n  const insertNode = function (tree, folderId, item, isFolder) {\r\n    if (tree.id === folderId && tree.isFolder) {\r\n      tree.items.unshift({\r\n        id:new Date().getTime(),\r\n        name: item,\r\n        isFolder: isFolder,\r\n        items: []\r\n      });\r\n\r\n      return tree;\r\n    }\r\n\r\n    let latestNode = [];\r\n    latestNode = tree.items.map((ob) => {\r\n      return insertNode(ob, folderId, item, isFolder);\r\n    });\r\n\r\n    return { ...tree, items: latestNode };\r\n  };\r\n\r\n\r\n  const selectInnerFiles = function (tree,isSelected){\r\n    if(tree.isFolder){\r\n      tree.isSelected = isSelected\r\n      tree.items.forEach((item) => {\r\n        selectInnerFiles(item,isSelected)\r\n      });\r\n\r\n    }else{\r\n      tree.isSelected = isSelected;\r\n    }\r\n    return tree;\r\n  }\r\n  \r\n\r\n  const updateParentSelection = function (tree) {\r\n    if (tree.isFolder) {\r\n      let allChildrenSelected = true;\r\n      for (const item of tree.items) {\r\n        if (item.isFolder) {\r\n          updateParentSelection(item); // Recursively update child folders\r\n        }\r\n        if (!item.isSelected) {\r\n          allChildrenSelected = false;\r\n          break;\r\n        }\r\n      }\r\n      tree.isSelected = allChildrenSelected;\r\n    }\r\n  };\r\n\r\n\r\n  const selectNode = function (tree, folderId) {\r\n\r\n    if(tree.id === folderId){\r\n     return selectInnerFiles(tree,!tree.isSelected)\r\n    }\r\n   \r\n    tree.items.forEach((item) => {\r\n      selectNode(item, folderId);\r\n    });\r\n\r\n\r\n    updateParentSelection(tree);\r\n       \r\n    return tree;\r\n  \r\n\r\n\r\n  };\r\n\r\n  \r\n\r\n  return { insertNode,selectNode};\r\n};\r\n\r\nexport default useTraverseTree;"],"mappings":"AAAA,MAAMA,eAAe,GAAGA,CAAA,KAAM;EAC5B;EACA;EACA,MAAMC,UAAU,GAAG,SAAAA,CAAUC,IAAI,EAAEC,QAAQ,EAAEC,IAAI,EAAEC,QAAQ,EAAE;IAC3D,IAAIH,IAAI,CAACI,EAAE,KAAKH,QAAQ,IAAID,IAAI,CAACG,QAAQ,EAAE;MACzCH,IAAI,CAACK,KAAK,CAACC,OAAO,CAAC;QACjBF,EAAE,EAAC,IAAIG,IAAI,CAAC,CAAC,CAACC,OAAO,CAAC,CAAC;QACvBC,IAAI,EAAEP,IAAI;QACVC,QAAQ,EAAEA,QAAQ;QAClBE,KAAK,EAAE;MACT,CAAC,CAAC;MAEF,OAAOL,IAAI;IACb;IAEA,IAAIU,UAAU,GAAG,EAAE;IACnBA,UAAU,GAAGV,IAAI,CAACK,KAAK,CAACM,GAAG,CAAEC,EAAE,IAAK;MAClC,OAAOb,UAAU,CAACa,EAAE,EAAEX,QAAQ,EAAEC,IAAI,EAAEC,QAAQ,CAAC;IACjD,CAAC,CAAC;IAEF,OAAO;MAAE,GAAGH,IAAI;MAAEK,KAAK,EAAEK;IAAW,CAAC;EACvC,CAAC;EAGD,MAAMG,gBAAgB,GAAG,SAAAA,CAAUb,IAAI,EAACc,UAAU,EAAC;IACjD,IAAGd,IAAI,CAACG,QAAQ,EAAC;MACfH,IAAI,CAACc,UAAU,GAAGA,UAAU;MAC5Bd,IAAI,CAACK,KAAK,CAACU,OAAO,CAAEb,IAAI,IAAK;QAC3BW,gBAAgB,CAACX,IAAI,EAACY,UAAU,CAAC;MACnC,CAAC,CAAC;IAEJ,CAAC,MAAI;MACHd,IAAI,CAACc,UAAU,GAAGA,UAAU;IAC9B;IACA,OAAOd,IAAI;EACb,CAAC;EAGD,MAAMgB,qBAAqB,GAAG,SAAAA,CAAUhB,IAAI,EAAE;IAC5C,IAAIA,IAAI,CAACG,QAAQ,EAAE;MACjB,IAAIc,mBAAmB,GAAG,IAAI;MAC9B,KAAK,MAAMf,IAAI,IAAIF,IAAI,CAACK,KAAK,EAAE;QAC7B,IAAIH,IAAI,CAACC,QAAQ,EAAE;UACjBa,qBAAqB,CAACd,IAAI,CAAC,CAAC,CAAC;QAC/B;;QACA,IAAI,CAACA,IAAI,CAACY,UAAU,EAAE;UACpBG,mBAAmB,GAAG,KAAK;UAC3B;QACF;MACF;MACAjB,IAAI,CAACc,UAAU,GAAGG,mBAAmB;IACvC;EACF,CAAC;EAGD,MAAMC,UAAU,GAAG,SAAAA,CAAUlB,IAAI,EAAEC,QAAQ,EAAE;IAE3C,IAAGD,IAAI,CAACI,EAAE,KAAKH,QAAQ,EAAC;MACvB,OAAOY,gBAAgB,CAACb,IAAI,EAAC,CAACA,IAAI,CAACc,UAAU,CAAC;IAC/C;IAEAd,IAAI,CAACK,KAAK,CAACU,OAAO,CAAEb,IAAI,IAAK;MAC3BgB,UAAU,CAAChB,IAAI,EAAED,QAAQ,CAAC;IAC5B,CAAC,CAAC;IAGFe,qBAAqB,CAAChB,IAAI,CAAC;IAE3B,OAAOA,IAAI;EAIb,CAAC;EAID,OAAO;IAAED,UAAU;IAACmB;EAAU,CAAC;AACjC,CAAC;AAED,eAAepB,eAAe"},"metadata":{},"sourceType":"module","externalDependencies":[]}